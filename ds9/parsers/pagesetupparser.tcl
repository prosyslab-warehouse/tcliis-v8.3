package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval pagesetup {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc pagesetup::YYABORT {} {
    return -code return 1
}

proc pagesetup::YYACCEPT {} {
    return -code return 0
}

proc pagesetup::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc pagesetup::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc pagesetup::yyerror {s} {
    puts stderr $s
}

proc pagesetup::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc pagesetup::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set pagesetup::table {
  15:259 reduce
  3:268,target 15
  17:259 reduce
  0:260 shift
  2:257 shift
  5:0,target 3
  15:0,target 14
  9:0 reduce
  0:261 shift
  2:258 shift
  6:259,target 9
  11:0 reduce
  0:262 shift
  18:259,target 19
  3:267,target 14
  15:0 reduce
  6:259 reduce
  13:259,target 12
  8:259 reduce
  6:0,target 9
  19:0 reduce
  16:0,target 15
  0:271 goto
  2:270 goto
  9:259,target 1
  0:273 goto
  3:266,target 13
  6:0 reduce
  16:259,target 15
  7:0,target 10
  17:0,target 8
  12:0 reduce
  3:265,target 12
  10:0,target 2
  3:275,target 17
  11:259,target 7
  16:0 reduce
  0:273,target 5
  10:259 reduce
  7:259,target 10
  12:259 reduce
  8:0,target 6
  5:272,target 18
  14:259 reduce
  11:0,target 7
  0:262,target 3
  2:270,target 11
  16:259 reduce
  7:0 reduce
  14:259,target 13
  18:259 shift
  13:0 reduce
  9:0,target 1
  0:261,target 2
  1:263 shift
  2:258,target 10
  19:0,target 5
  0:271,target 4
  1:264 shift
  5:259 reduce
  12:0,target 11
  7:259 reduce
  17:0 reduce
  1:264,target 7
  3:265 shift
  5:259,target 4
  9:259 reduce
  1:274,target 8
  3:266 shift
  3:267 shift
  17:259,target 8
  0:260,target 1
  2:257,target 9
  3:268 shift
  3:269 shift
  4:0 accept
  12:259,target 11
  1:274 goto
  13:0,target 12
  1:263,target 6
  8:0 reduce
  5:272 goto
  10:0 reduce
  3:275 goto
  8:259,target 6
  14:0 reduce
  3:269,target 16
  4:0,target 0
  14:0,target 13
  15:259,target 14
  11:259 reduce
  13:259 reduce
  10:259,target 2
  5:0 reduce
}

array set pagesetup::rules {
  9,l 274
  11,l 275
  15,l 275
  2,l 270
  6,l 273
  12,l 275
  3,l 271
  7,l 273
  13,l 275
  0,l 276
  4,l 272
  8,l 273
  10,l 274
  14,l 275
  1,l 270
  5,l 271
}

array set pagesetup::rules {
  5,dc 3
  0,dc 1
  12,dc 1
  8,dc 2
  3,dc 1
  15,dc 1
  10,dc 1
  6,dc 2
  1,dc 1
  13,dc 1
  9,dc 1
  4,dc 0
  11,dc 1
  7,dc 2
  2,dc 1
  14,dc 1
}

array set pagesetup::rules {
  13,line 52
  7,line 42
  10,line 47
  4,line 37
  1,line 33
  15,line 54
  9,line 46
  12,line 51
  6,line 41
  3,line 37
  4,e 1
  14,line 53
  8,line 43
  11,line 50
  5,line 38
  2,line 34
}

array set pagesetup::lr1_table {
  13,trans {}
  17 {{8 {0 259} 2}}
  0 {{0 0 0} {3 0 0} {5 0 0} {6 {0 259} 0} {7 {0 259} 0} {8 {0 259} 0}}
  14,trans {}
  18 {{5 0 2}}
  1 {{6 {0 259} 1} {9 {0 259} 0} {10 {0 259} 0}}
  19 {{5 0 3}}
  15,trans {}
  2 {{7 {0 259} 1} {1 {0 259} 0} {2 {0 259} 0}}
  16,trans {}
  3 {{8 {0 259} 1} {11 {0 259} 0} {12 {0 259} 0} {13 {0 259} 0} {14 {0 259} 0} {15 {0 259} 0}}
  17,trans {}
  4 {{0 0 1}}
  0,trans {{260 1} {261 2} {262 3} {271 4} {273 5}}
  18,trans {{259 19}}
  5 {{3 0 1} {5 0 1} {4 259 0}}
  1,trans {{263 6} {264 7} {274 8}}
  19,trans {}
  2,trans {{257 9} {258 10} {270 11}}
  6 {{9 {0 259} 1}}
  3,trans {{265 12} {266 13} {267 14} {268 15} {269 16} {275 17}}
  7 {{10 {0 259} 1}}
  4,trans {}
  8 {{6 {0 259} 2}}
  5,trans {{272 18}}
  10 {{2 {0 259} 1}}
  9 {{1 {0 259} 1}}
  6,trans {}
  11 {{7 {0 259} 2}}
  7,trans {}
  12 {{11 {0 259} 1}}
  8,trans {}
  13 {{12 {0 259} 1}}
  10,trans {}
  9,trans {}
  14 {{13 {0 259} 1}}
  11,trans {}
  15 {{14 {0 259} 1}}
  12,trans {}
  16 {{15 {0 259} 1}}
}

array set pagesetup::token_id_table {
  264,line 19
  270,t 1
  269,t 0
  276,line 55
  265,title LETTER
  274,t 1
  261,line 15
  257,t 0
  270,title {}
  269,title A4
  273,line 40
  257,line 7
  262,t 0
  274,title {}
  270,line 32
  269,line 25
  259,title string
  260,title ORIENT
  266,t 0
  271,t 1
  error error
  264,title LANDSCAPE
  266,line 22
  275,t 1
  error,line 31
  268,title POSTER
  258,t 0
  263,line 18
  error,title {}
  275,line 49
  273,title {}
  263,t 0
  259,line 10
  260,line 14
  258,title float
  272,line 37
  267,t 0
  263,title PORTRAIT
  272,t 1
  268,line 24
  267,title TABLOID
  257 INT_
  276,t 1
  258 REAL_
  259,t 0
  259 STRING_
  260 ORIENT_
  260,t 0
  272,title {}
  261 SCALE_
  265,line 21
  262 SIZE_
  263 PORTRAIT_
  257,title integer
  264 LANDSCAPE_
  264,t 0
  276,title {}
  265 LETTER_
  262,line 16
  266 LEGAL_
  267 TABLOID_
  0,t 0
  0 {$}
  262,title SIZE
  268 POSTER_
  268,t 0
  274,line 45
  270 numeric
  269 A4_
  271 command
  error,t 0
  272 @PSEUDO1
  258,line 8
  273,t 1
  273 pagesetup
  266,title LEGAL
  274 orient
  275 size
  271,line 36
  276 start'
  271,title {}
  261,t 0
  267,line 23
  275,title {}
  265,t 0
  261,title SCALE
}

proc pagesetup::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { set _ $1 }
                    2 { set _ $1 }
                    4 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    6 { ProcessCmdSet ps orient $2 }
                    7 { ProcessCmdSet ps scale $2 }
                    8 { ProcessCmdSet ps size $2 }
                    9 { set _ portrait }
                    10 { set _ landscape }
                    11 { set _ letter }
                    12 { set _ legal }
                    13 { set _ tabloid }
                    14 { set _ poster }
                    15 { set _ a4 }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc pagesetup::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
