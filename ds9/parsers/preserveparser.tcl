package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval preserve {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc preserve::YYABORT {} {
    return -code return 1
}

proc preserve::YYACCEPT {} {
    return -code return 0
}

proc preserve::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc preserve::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc preserve::yyerror {s} {
    puts stderr $s
}

proc preserve::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc preserve::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set preserve::table {
  13:263 reduce
  11:263,target 7
  5:0,target 8
  2:257 shift
  15:263 shift
  9:0 reduce
  0:266,target 3
  2:258 shift
  11:0 reduce
  2:259 shift
  2:260 shift
  2:261 shift
  3:257,target 6
  0:264 shift
  1:259,target 8
  1:260,target 9
  2:262 shift
  7:263,target 5
  3:267,target 14
  0:265 shift
  2:263 reduce
  0:266 shift
  0:265,target 2
  0:268 goto
  2:263,target 1
  6:263 reduce
  6:0,target 2
  0:270 goto
  2:267 goto
  16:0,target 10
  2:0 reduce
  14:263,target 13
  8:263 reduce
  1:258,target 7
  6:0 reduce
  0:264,target 1
  2:262,target 11
  7:0,target 5
  1:257,target 6
  12:0 reduce
  5:263,target 9
  1:267,target 12
  10:0,target 4
  2:261,target 10
  16:0 reduce
  12:263,target 11
  8:0,target 3
  3:0 reduce
  10:263 reduce
  1:0,target 1
  11:0,target 7
  2:259,target 8
  2:260,target 9
  12:263 reduce
  8:263,target 3
  7:0 reduce
  1:257 shift
  14:263 reduce
  1:258 shift
  3:257 shift
  3:263,target 1
  1:259 shift
  1:260 shift
  3:258 shift
  1:261 shift
  3:260 shift
  3:259 shift
  1:262 shift
  15:263,target 16
  13:0 reduce
  9:0,target 6
  3:261 shift
  1:263 reduce
  2:258,target 7
  3:262 shift
  2:0,target 1
  12:0,target 11
  3:263 reduce
  10:263,target 4
  5:263 reduce
  3:262,target 11
  1:267 goto
  5:269,target 15
  7:263 reduce
  3:267 goto
  2:257,target 6
  9:263 reduce
  6:263,target 2
  4:0 accept
  0:270,target 5
  2:267,target 13
  5:269 goto
  3:0,target 1
  13:0,target 12
  3:261,target 10
  1:263,target 1
  8:0 reduce
  10:0 reduce
  13:263,target 12
  0:268,target 4
  14:0 reduce
  3:260,target 9
  3:259,target 8
  1:262,target 11
  9:263,target 6
  4:0,target 0
  14:0,target 13
  1:0 reduce
  11:263 reduce
  5:0 reduce
  3:258,target 7
  1:261,target 10
}

array set preserve::rules {
  9,l 269
  11,l 270
  2,l 267
  6,l 267
  12,l 270
  3,l 267
  7,l 267
  13,l 270
  0,l 271
  4,l 267
  8,l 268
  10,l 268
  1,l 267
  5,l 267
}

array set preserve::rules {
  5,dc 1
  0,dc 1
  12,dc 2
  8,dc 1
  3,dc 1
  10,dc 3
  6,dc 1
  1,dc 0
  13,dc 2
  9,dc 0
  4,dc 1
  11,dc 2
  7,dc 1
  2,dc 1
}

array set preserve::rules {
  13,line 49
  7,line 39
  10,line 43
  4,line 36
  1,line 33
  9,line 42
  12,line 48
  6,line 38
  3,line 35
  8,line 42
  11,line 46
  5,line 37
  2,line 34
  9,e 1
}

array set preserve::lr1_table {
  13,trans {}
  0 {{0 0 0} {8 0 0} {10 0 0} {11 {0 263} 0} {12 {0 263} 0} {13 {0 263} 0}}
  14,trans {}
  1 {{11 {0 263} 1} {1 {0 263} 0} {2 {0 263} 0} {3 {0 263} 0} {4 {0 263} 0} {5 {0 263} 0} {6 {0 263} 0} {7 {0 263} 0}}
  15,trans {{263 16}}
  2 {{12 {0 263} 1} {1 {0 263} 0} {2 {0 263} 0} {3 {0 263} 0} {4 {0 263} 0} {5 {0 263} 0} {6 {0 263} 0} {7 {0 263} 0}}
  16,trans {}
  3 {{13 {0 263} 1} {1 {0 263} 0} {2 {0 263} 0} {3 {0 263} 0} {4 {0 263} 0} {5 {0 263} 0} {6 {0 263} 0} {7 {0 263} 0}}
  4 {{0 0 1}}
  0,trans {{264 1} {265 2} {266 3} {268 4} {270 5}}
  1,trans {{257 6} {258 7} {259 8} {260 9} {261 10} {262 11} {267 12}}
  5 {{8 0 1} {10 0 1} {9 263 0}}
  2,trans {{257 6} {258 7} {259 8} {260 9} {261 10} {262 11} {267 13}}
  6 {{2 {0 263} 1}}
  3,trans {{257 6} {258 7} {259 8} {260 9} {261 10} {262 11} {267 14}}
  7 {{5 {0 263} 1}}
  4,trans {}
  8 {{3 {0 263} 1}}
  5,trans {{269 15}}
  9 {{6 {0 263} 1}}
  10 {{4 {0 263} 1}}
  6,trans {}
  11 {{7 {0 263} 1}}
  7,trans {}
  12 {{11 {0 263} 2}}
  8,trans {}
  13 {{12 {0 263} 2}}
  10,trans {}
  9,trans {}
  14 {{13 {0 263} 2}}
  11,trans {}
  15 {{10 0 2}}
  16 {{10 0 3}}
  12,trans {}
}

array set preserve::token_id_table {
  264,line 18
  270,t 1
  269,t 1
  265,title REGIONS
  261,line 11
  257,t 0
  270,title {}
  269,title {}
  257,line 7
  262,t 0
  270,line 45
  269,line 42
  259,title ON
  260,title OFF
  266,t 0
  271,t 1
  264,title PAN
  266,line 20
  error error
  268,title {}
  error,line 31
  258,t 0
  263,line 14
  error,title {}
  263,t 0
  259,line 9
  260,line 10
  258,title NO
  267,t 1
  263,title string
  268,line 41
  267,title {}
  257 YES_
  258 NO_
  259,t 0
  259 ON_
  260 OFF_
  260,t 0
  261 TRUE_
  265,line 19
  262 FALSE_
  263 STRING_
  257,title YES
  264 PAN_
  264,t 0
  265 REGIONS_
  262,line 12
  266 SCALE_
  267 yesno
  268,t 1
  268 command
  262,title FALSE
  0 {$}
  0,t 0
  270 preserve
  269 @PSEUDO1
  271 start'
  error,t 0
  258,line 8
  266,title SCALE
  271,line 50
  271,title {}
  261,t 0
  267,line 32
  265,t 0
  261,title TRUE
}

proc preserve::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    1 { set _ 1 }
                    2 { set _ 1 }
                    3 { set _ 1 }
                    4 { set _ 1 }
                    5 { set _ 0 }
                    6 { set _ 0 }
                    7 { set _ 0 }
                    9 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    11 { ProcessCmdSet panzoom preserve $2 PreservePan }
                    12 { ProcessCmdSet marker preserve $2 MarkerPreserve }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc preserve::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
