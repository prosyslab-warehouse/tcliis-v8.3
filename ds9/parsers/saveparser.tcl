package provide DS9 1.0

######
# Begin autogenerated taccle (version 1.3) routines.
# Although taccle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/taccle for other details.
######

namespace eval save {
    variable yylval {}
    variable table
    variable rules
    variable token {}
    variable yycnt 0
    variable yyerr 0
    variable save_state 0

    namespace export yylex
}

proc save::YYABORT {} {
    return -code return 1
}

proc save::YYACCEPT {} {
    return -code return 0
}

proc save::YYERROR {} {
    variable yyerr
    set yyerr 1
}

proc save::yyclearin {} {
    variable token
    variable yycnt
    set token {}
    incr yycnt -1
}

proc save::yyerror {s} {
    puts stderr $s
}

proc save::setupvalues {stack pointer numsyms} {
    upvar 1 1 y
    set y {}
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        set y [lindex $stack $pointer]
        incr pointer
    }
}

proc save::unsetupvalues {numsyms} {
    for {set i 1} {$i <= $numsyms} {incr i} {
        upvar 1 $i y
        unset y
    }
}

array set save::table {
  17:258 reduce
  0:258 shift
  23:0,target 18
  15:258,target 22
  0:260 shift
  0:259 shift
  20:258 reduce
  19:258 reduce
  15:0,target 22
  0:261 shift
  0:266,target 9
  2:258 reduce
  11:0 reduce
  8:267,target 21
  0:262 shift
  0:276,target 14
  22:258 shift
  0:263 shift
  4:258 reduce
  0:264 shift
  11:272 goto
  6:258 reduce
  0:265 shift
  1:269,target 17
  1:270,target 18
  15:0 reduce
  0:266 shift
  8:258 reduce
  11:272,target 22
  6:258,target 12
  0:265,target 8
  24:0,target 3
  0:275,target 13
  19:0 reduce
  16:0,target 19
  0:271 goto
  18:258,target 21
  1:258,target 18
  0:273 goto
  1:268,target 16
  6:267 shift
  0:274 goto
  24:0 reduce
  13:258,target 10
  0:275 goto
  8:267 shift
  0:276 goto
  0:264,target 7
  6:267,target 20
  0:274,target 12
  25:0,target 5
  1:257,target 15
  17:0,target 20
  9:258,target 17
  10:0,target 0
  1:277,target 19
  22:258,target 24
  4:258,target 8
  0:263,target 6
  16:0 reduce
  0:273,target 11
  16:258,target 19
  12:258 shift
  18:0,target 21
  14:258 reduce
  11:258,target 2
  1:0,target 18
  11:0,target 1
  0:262,target 5
  16:258 reduce
  25:0 reduce
  1:257 shift
  18:258 reduce
  1:258 reduce
  25:258,target 5
  7:258,target 14
  21:258 reduce
  3:258 reduce
  23:257 shift
  23:258 reduce
  20:258,target 13
  19:258,target 4
  5:258 reduce
  0:261,target 4
  2:258,target 6
  19:0,target 4
  0:271,target 10
  25:258 reduce
  7:258 reduce
  14:258,target 11
  17:0 reduce
  9:258 reduce
  23:270,target 18
  23:269,target 17
  1:268 shift
  1:269 shift
  1:270 shift
  0:259,target 2
  0:260,target 3
  23:268 shift
  23:270 shift
  23:269 shift
  23:258,target 18
  5:258,target 9
  23:268,target 16
  10:0 accept
  1:277 goto
  17:258,target 20
  0:258,target 1
  23:277 goto
  12:258,target 23
  23:257,target 15
  23:277,target 25
  18:0 reduce
  11:258 reduce
  1:0 reduce
  8:258,target 15
  13:258 reduce
  23:0 reduce
  21:258,target 16
  15:258 reduce
  3:258,target 7
}

array set save::rules {
  9,l 274
  11,l 274
  15,l 276
  20,l 277
  19,l 277
  2,l 272
  6,l 274
  12,l 275
  16,l 276
  21,l 277
  3,l 271
  7,l 274
  13,l 275
  0,l 278
  17,l 276
  22,l 277
  4,l 273
  8,l 274
  10,l 274
  14,l 275
  18,l 277
  1,l 271
  5,l 273
}

array set save::rules {
  5,dc 3
  0,dc 1
  17,dc 1
  12,dc 1
  8,dc 1
  21,dc 1
  3,dc 3
  15,dc 1
  10,dc 1
  6,dc 1
  18,dc 0
  1,dc 1
  13,dc 2
  9,dc 1
  22,dc 1
  4,dc 2
  16,dc 2
  11,dc 1
  7,dc 1
  20,dc 1
  19,dc 1
  2,dc 0
  14,dc 1
}

array set save::rules {
  13,line 47
  2,e 1
  7,line 39
  10,line 42
  22,line 60
  4,line 34
  18,line 56
  1,line 30
  15,line 51
  9,line 41
  12,line 46
  6,line 38
  21,line 59
  3,line 31
  17,line 53
  14,line 48
  8,line 40
  11,line 43
  5,line 35
  20,line 58
  19,line 57
  2,line 30
  16,line 52
}

array set save::lr1_table {
  14,trans {}
  1,trans {{257 15} {268 16} {269 17} {270 18} {277 19}}
  18,trans {}
  23,trans {{257 15} {268 16} {269 17} {270 18} {277 25}}
  5,trans {}
  9,trans {}
  13,trans {}
  0,trans {{258 1} {259 2} {260 3} {261 4} {262 5} {263 6} {264 7} {265 8} {266 9} {271 10} {273 11} {274 12} {275 13} {276 14}}
  17,trans {}
  4,trans {}
  22,trans {{258 24}}
  8,trans {{267 21}}
  12,trans {{258 23}}
  16,trans {}
  3,trans {}
  21,trans {}
  10 {{0 0 1}}
  11 {{1 0 1} {3 0 1} {2 258 0}}
  25,trans {}
  12 {{5 {0 258} 1}}
  7,trans {}
  13 {{10 258 1}}
  14 {{11 258 1}}
  15 {{22 {0 258} 1}}
  11,trans {{272 22}}
  16 {{19 {0 258} 1}}
  0 {{0 0 0} {1 0 0} {3 0 0} {4 {0 258} 0} {5 {0 258} 0} {6 258 0} {7 258 0} {8 258 0} {9 258 0} {10 258 0} {11 258 0} {12 258 0} {13 258 0} {14 258 0} {15 258 0} {16 258 0} {17 258 0}}
  17 {{20 {0 258} 1}}
  1 {{4 {0 258} 1} {18 {0 258} 0} {19 {0 258} 0} {20 {0 258} 0} {21 {0 258} 0} {22 {0 258} 0}}
  18 {{21 {0 258} 1}}
  2 {{6 258 1}}
  19 {{4 {0 258} 2}}
  20 {{13 258 2}}
  15,trans {}
  3 {{7 258 1}}
  21 {{16 258 2}}
  4 {{8 258 1}}
  22 {{3 0 2}}
  5 {{9 258 1}}
  23 {{5 {0 258} 2} {18 {0 258} 0} {19 {0 258} 0} {20 {0 258} 0} {21 {0 258} 0} {22 {0 258} 0}}
  6 {{12 258 1} {13 258 1}}
  2,trans {}
  19,trans {}
  20,trans {}
  24 {{3 0 3}}
  25 {{5 {0 258} 3}}
  7 {{14 258 1}}
  8 {{15 258 1} {16 258 1}}
  9 {{17 258 1}}
  24,trans {}
  6,trans {{267 20}}
  10,trans {}
}

array set save::token_id_table {
  264,line 18
  270,t 0
  269,t 0
  276,line 50
  265,title MOSAICIMAGE
  274,t 1
  261,line 15
  257,t 0
  270,title SLICE
  269,title TABLE
  273,line 33
  278,t 1
  257,line 7
  262,t 0
  274,title {}
  270,line 25
  269,line 24
  259,title FITS
  260,title RGBIMAGE
  266,t 0
  278,title {}
  271,t 1
  error error
  264,title MOSAICWCS
  266,line 20
  278,line 61
  275,t 1
  error,line 28
  268,title IMAGE
  258,t 0
  263,line 17
  error,title {}
  275,line 45
  273,title {}
  263,t 0
  259,line 13
  260,line 14
  258,title string
  277,title {}
  272,line 30
  267,t 0
  263,title MOSAIC
  272,t 1
  268,line 23
  267,title WCS
  257 INT_
  276,t 1
  258 STRING_
  259,t 0
  259 FITS_
  260 RGBIMAGE_
  260,t 0
  272,title {}
  261 RGBCUBE_
  265,line 19
  262 MECUBE_
  263 MOSAIC_
  277,line 55
  257,title integer
  264 MOSAICWCS_
  264,t 0
  276,title {}
  265 MOSAICIMAGE_
  262,line 16
  266 MOSAICIMAGEWCS_
  267 WCS_
  0,t 0
  0 {$}
  262,title MECUBE
  268 IMAGE_
  268,t 0
  274,line 37
  270 SLICE_
  269 TABLE_
  271 command
  error,t 0
  272 @PSEUDO1
  258,line 9
  273,t 1
  273 save
  266,title MOSAICIMAGEWCS
  274 format
  275 mosaic
  271,line 29
  276 mosaicimage
  277,t 1
  277 opts
  271,title {}
  278 start'
  261,t 0
  267,line 21
  275,title {}
  265,t 0
  261,title RGBCUBE
}

proc save::yyparse {} {
    variable yylval
    variable table
    variable rules
    variable token
    variable yycnt
    variable lr1_table
    variable token_id_table
    variable yyerr
    variable save_state

    set yycnt 0
    set state_stack {0}
    set value_stack {{}}
    set token ""
    set accepted 0
    set yyerr 0
    set save_state 0

    while {$accepted == 0} {
        set state [lindex $state_stack end]
        if {$token == ""} {
            set yylval ""
            set token [yylex]
            set buflval $yylval
	    if {$token>0} {
	        incr yycnt
            }
        }
        if {![info exists table($state:$token)] || $yyerr} {
	    if {!$yyerr} {
	        set save_state $state
	    }
            # pop off states until error token accepted
            while {[llength $state_stack] > 0 && \
                       ![info exists table($state:error)]} {
                set state_stack [lrange $state_stack 0 end-1]
                set value_stack [lrange $value_stack 0 \
                                       [expr {[llength $state_stack] - 1}]]
                set state [lindex $state_stack end]
            }
            if {[llength $state_stack] == 0} {
 
	        set rr { }
                if {[info exists lr1_table($save_state,trans)] && [llength $lr1_table($save_state,trans)] >= 1} {
                    foreach trans $lr1_table($save_state,trans) {
                        foreach {tok_id nextstate} $trans {
			    set ss $token_id_table($tok_id,title)
			    if {$ss != {}} {
			        append rr "$ss, "
                            }
                        }
                    }
                }
		set rr [string trimleft $rr { }]
		set rr [string trimright $rr {, }]
                yyerror "parse error, expecting: $rr"


                return 1
            }
            lappend state_stack [set state $table($state:error,target)]
            lappend value_stack {}
            # consume tokens until it finds an acceptable one
            while {![info exists table($state:$token)]} {
                if {$token == 0} {
                    yyerror "end of file while recovering from error"
                    return 1
                }
                set yylval {}
                set token [yylex]
                set buflval $yylval
            }
            continue
        }
        switch -- $table($state:$token) {
            shift {
                lappend state_stack $table($state:$token,target)
                lappend value_stack $buflval
                set token ""
            }
            reduce {
                set rule $table($state:$token,target)
                set ll $rules($rule,l)
                if {[info exists rules($rule,e)]} {
                    set dc $rules($rule,e)
                } else {
                    set dc $rules($rule,dc)
                }
                set stackpointer [expr {[llength $state_stack]-$dc}]
                setupvalues $value_stack $stackpointer $dc
                set _ $1
                set yylval [lindex $value_stack end]
                switch -- $rule {
                    2 { global ds9; if {!$ds9(init)} {YYERROR} else {yyclearin; YYACCEPT} }
                    4 { SaveCmdLoad [ExtToFormat $1] $1 }
                    5 { SaveCmdLoad $1 $2 }
                    6 { set _ fits }
                    7 { set _ rgbimage }
                    8 { set _ rgbcube }
                    9 { set _ mecube }
                    10 { set _ $1 }
                    11 { set _ $1 }
                    12 { set _ mosaic }
                    13 { set _ mosaic }
                    14 { set _ mosaic }
                    15 { set _ mosaicimage }
                    16 { set _ mosaicimage }
                    17 { set _ mosaicimage }
                    18 { ProcessCmdSet savefits type image; ProcessCmdSet savefits mosaic 1 }
                    19 { ProcessCmdSet savefits type image }
                    20 { ProcessCmdSet savefits type table }
                    21 { ProcessCmdSet savefits type slice }
                    22 { ProcessCmdSet savefits mosaic $1 }
                }
                unsetupvalues $dc
                # pop off tokens from the stack if normal rule
                if {![info exists rules($rule,e)]} {
                    incr stackpointer -1
                    set state_stack [lrange $state_stack 0 $stackpointer]
                    set value_stack [lrange $value_stack 0 $stackpointer]
                }
                # now do the goto transition
                lappend state_stack $table([lindex $state_stack end]:$ll,target)
                lappend value_stack $_
            }
            accept {
                set accepted 1
            }
            goto -
            default {
                puts stderr "Internal parser error: illegal command $table($state:$token)"
                return 2
            }
        }
    }
    return 0
}

######
# end autogenerated taccle functions
######

proc save::yyerror {msg} {
     variable yycnt
     variable yy_current_buffer
     variable index_

     ParserError $msg $yycnt $yy_current_buffer $index_
}
